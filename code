import os
import time
import random
from typing import Optional, List, Dict, Tuple
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class Stats:
    """Character statistics"""
    hp: int
    max_hp: int
    mp: int
    max_mp: int
    attack: int
    speed: int
    level: int = 1
    exp: int = 0
    
    # Active status effects (buffs/debuffs)
    attack_modifier: int = 0  # Temporary attack change
    speed_modifier: int = 0   # Temporary speed change
    attack_modifier_turns: int = 0  # Turns remaining for attack modifier
    speed_modifier_turns: int = 0   # Turns remaining for speed modifier
    
    def get_effective_attack(self) -> int:
        """Get attack with modifiers applied"""
        return max(1, self.attack + self.attack_modifier)
    
    def get_effective_speed(self) -> int:
        """Get speed with modifiers applied"""
        return max(1, self.speed + self.speed_modifier)
    
    def apply_attack_modifier(self, amount: int, duration: int):
        """Apply temporary attack change"""
        self.attack_modifier += amount
        self.attack_modifier_turns = max(self.attack_modifier_turns, duration)
    
    def apply_speed_modifier(self, amount: int, duration: int):
        """Apply temporary speed change"""
        self.speed_modifier += amount
        self.speed_modifier_turns = max(self.speed_modifier_turns, duration)
    
    def tick_status_effects(self):
        """Reduce duration of status effects by 1 turn"""
        # Attack modifier
        if self.attack_modifier_turns > 0:
            self.attack_modifier_turns -= 1
            if self.attack_modifier_turns == 0:
                self.attack_modifier = 0
        
        # Speed modifier
        if self.speed_modifier_turns > 0:
            self.speed_modifier_turns -= 1
            if self.speed_modifier_turns == 0:
                self.speed_modifier = 0
    
    def has_active_effects(self) -> bool:
        """Check if any status effects are active"""
        return self.attack_modifier_turns > 0 or self.speed_modifier_turns > 0
    
    def get_status_effects_text(self) -> str:
        """Get text description of active effects"""
        effects = []
        if self.attack_modifier_turns > 0:
            sign = "+" if self.attack_modifier > 0 else ""
            effects.append(f"ATK {sign}{self.attack_modifier} ({self.attack_modifier_turns} turns)")
        if self.speed_modifier_turns > 0:
            sign = "+" if self.speed_modifier > 0 else ""
            effects.append(f"SPD {sign}{self.speed_modifier} ({self.speed_modifier_turns} turns)")
        return ", ".join(effects) if effects else "None"
    
    def take_damage(self, damage: int) -> int:
        actual_damage = max(1, damage)
        self.hp = max(0, self.hp - actual_damage)
        return actual_damage
    
    def heal(self, amount: int) -> int:
        actual_heal = max(1, amount)
        self.hp = min(self.max_hp, self.hp + amount)
        return actual_heal

    def is_alive(self) -> bool:
        return self.hp > 0
    
    def use_mp(self, amount: int) -> bool:
        """
        Try to use MP. Returns True if successful, False if not enough MP.
        """
        if self.mp >= amount:
            self.mp -= amount
            return True
        return False
    
    def restore_mp(self, amount: int):
        """Restore MP, not exceeding max"""
        self.mp = min(self.max_mp, self.mp + amount)

@dataclass
class Skill:
    """A skill/spell that costs MP to use"""
    name: str
    description: str
    mp_cost: int
    skill_type: str  # "damage", "heal", "buff", "debuff"
    power: float = 0.0  # Multiplier for ALL skill types
    # Examples:
    # damage: 1.5 = deals 150% of attack as damage
    # heal: 0.5 = heals 50% of attack
    # buff: 0.2 = increases target's attack by 20% of caster's attack
    # debuff: 0.3 = decreases target's attack by 30% of caster's attack
    duration: int = 0  # How many turns buff/debuff lasts (0 = instant)

class Entity:
    """Base class for all game characters"""
    
    def __init__(self, name: str, stats: Stats, ascii_art: str = ""):
        self.name = name
        self.stats = stats
        self.ascii_art = ascii_art
    
    def basic_attack(self, target: 'Entity') -> Tuple[int, str]:
        """Attack another entity using effective attack (with buffs/debuffs)"""
        # Use effective attack (includes buffs/debuffs)
        effective_attack = self.stats.get_effective_attack()
        damage = int(effective_attack * random.uniform(0.8, 1.2))
        actual_damage = target.stats.take_damage(damage)
        message = f"{self.name} attacks {target.name} for {actual_damage} damage!"
        return actual_damage, message

class Player(Entity, ABC):
    """
    Base Player class - must be subclassed (Warrior, Wizard, etc.)
    ABC = Abstract Base Class
    """
    
    def __init__(self, name: str, stats: Stats, class_name: str, ascii_art: str = ""):
        # Call Entity constructor
        super().__init__(name, stats, ascii_art)
        
        # Add player-specific attributes
        self.class_name = class_name
        self.inventory: List = []  # Empty list for items
        self.skills: List = []     # Empty list for skills
        self.gold: int = 0
        
        # Each subclass will define their own skills
        self._init_skills()
    
    @abstractmethod
    def _init_skills(self):
        """
        Each player class (Warrior, Wizard, etc.) must implement this
        This is where they add their unique skills
        """
        pass
    
    def gain_exp(self, exp: int):
        """Gain experience points"""
        self.stats.exp += exp
        exp_needed = self.stats.level * 100
        
        # Level up if enough exp
        if self.stats.exp >= exp_needed:
            self.level_up()
    
    def level_up(self):
        """Increase level and stats"""
        self.stats.level += 1
        self.stats.max_hp += int(self.stats.max_hp * 0.1)  # Increase max HP by 10%
        self.stats.max_mp += int(self.stats.max_mp * 0.1)  # Increase max MP by 10%
        self.stats.hp = self.stats.max_hp  # Full heal on level up
        self.stats.mp = self.stats.max_mp
        self.stats.attack += int(self.stats.attack * 0.1)  # Increase attack by 10%
        self.stats.speed += 1
        
        print(f"ðŸŽ‰ LEVEL UP! {self.name} is now level {self.stats.level}!")

    def use_skill(self, skill: Skill, target: Entity) -> Tuple[Optional[int], str]:
        """
        Use a skill on a target
        Returns: (damage_dealt, message) or (None, error_message)
        """
        # Check if player has enough MP
        if not self.stats.use_mp(skill.mp_cost):
            return None, f"Not enough MP! Need {skill.mp_cost} MP."
        
        # Calculate effect based on attacker's stats
        effect_amount = int(self.stats.attack * skill.power)
        
        # Handle different skill types
        if skill.skill_type == "damage":
            # Damage skill - use target's effective attack for their future attacks
            damage = int(effect_amount * random.uniform(0.9, 1.1))
            actual_damage = target.stats.take_damage(damage)
            message = f"{self.name} uses {skill.name}! Deals {actual_damage} damage!"
            return actual_damage, message
        
        elif skill.skill_type == "heal":
            # Healing skill (heals self or ally)
            # Target is usually self, but could heal others
            heal_amount = effect_amount
            target.stats.heal(heal_amount)
            message = f"{self.name} uses {skill.name}! Restored {heal_amount} HP to {target.name}!"
            return 0, message
        
        elif skill.skill_type == "buff":
            # Buff skill - increase target's stats temporarily
            # For now, buff attack (you can add more stat types later)
            buff_amount = max(1, effect_amount)  # At least +1
            target.stats.apply_attack_modifier(buff_amount, skill.duration)
            message = f"{self.name} uses {skill.name} on {target.name}! Attack +{buff_amount} for {skill.duration} turns!"
            return 0, message
        
        elif skill.skill_type == "debuff":
            # Debuff skill - decrease enemy stats temporarily
            debuff_amount = max(1, effect_amount)  # At least -1
            target.stats.apply_attack_modifier(-debuff_amount, skill.duration)
            message = f"{self.name} uses {skill.name} on {target.name}! Attack -{debuff_amount} for {skill.duration} turns!"
            return 0, message
        
        else:
            return None, f"Unknown skill type: {skill.skill_type}"

class Warrior(Player):
    """Warrior - High HP, powerful physical attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=120, max_hp=120,
            mp=30, max_mp=30,
            attack=18,
            speed=8
        )
        super().__init__(name, stats, "Warrior")
    
    def _init_skills(self):
        """Warrior gets physical damage skills and buffs"""
        self.skills = [
            Skill(
                name="Power Strike",
                description="Heavy attack dealing 150% damage",
                mp_cost=10,
                skill_type="damage",
                power=1.5
            ),
            Skill(
                name="Whirlwind",
                description="Spinning attack dealing 200% damage",
                mp_cost=20,
                skill_type="damage",
                power=2.0
            ),
            Skill(
                name="Battle Cry",
                description="Boost attack by 30% for 3 turns",
                mp_cost=15,
                skill_type="buff",
                power=0.3,  # 30% of attack
                duration=3
            ),
        ]

class Wizard(Player):
    """Wizard - High MP, powerful magic attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=80, max_hp=80,
            mp=60, max_mp=60,
            attack=12,
            speed=10
        )
        super().__init__(name, stats, "Wizard")
    
    def _init_skills(self):
        """Wizard gets elemental magic, healing, and debuffs"""
        self.skills = [
            Skill(
                name="Fireball",
                description="Fire spell dealing 160% damage",
                mp_cost=12,
                skill_type="damage",
                power=1.6
            ),
            Skill(
                name="Lightning Bolt",
                description="Electric spell dealing 220% damage",
                mp_cost=25,
                skill_type="damage",
                power=2.2
            ),
            Skill(
                name="Heal",
                description="Restore HP based on 80% of attack",
                mp_cost=15,
                skill_type="heal",
                power=0.8  # 80% of attack as healing
            ),
            Skill(
                name="Weaken",
                description="Reduce enemy attack by 40% for 2 turns",
                mp_cost=18,
                skill_type="debuff",
                power=0.4,  # 40% of caster's attack
                duration=2
            ),
        ]

class Ranger(Player):
    """Ranger - Balanced stats, ranged attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=100, max_hp=100,
            mp=40, max_mp=40,
            attack=15,
            speed=12
        )
        super().__init__(name, stats, "Ranger")
    
    def _init_skills(self):
        """Ranger gets precision attacks"""
        self.skills = [
            Skill(
                name="Rapid Shot",
                description="Quick attack dealing 130% damage",
                mp_cost=8,
                skill_type="damage",
                power=1.3
            ),
            Skill(
                name="Piercing Arrow",
                description="Armor-piercing shot dealing 180% damage",
                mp_cost=15,
                skill_type="damage",
                power=1.8
            ),
        ]

class Thief(Player):
    """Thief - Highest speed, critical strikes"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=90, max_hp=90,
            mp=35, max_mp=35,
            attack=14,
            speed=15
        )
        super().__init__(name, stats, "Thief")
    
    def _init_skills(self):
        """Thief gets critical strikes and debuffs"""
        self.skills = [
            Skill(
                name="Backstab",
                description="Critical strike dealing 170% damage",
                mp_cost=10,
                skill_type="damage",
                power=1.7
            ),
            Skill(
                name="Shadow Strike",
                description="Swift assassination dealing 250% damage",
                mp_cost=22,
                skill_type="damage",
                power=2.5
            ),
            Skill(
                name="Smoke Bomb",
                description="Reduce enemy attack by 35% for 2 turns",
                mp_cost=12,
                skill_type="debuff",
                power=0.35,
                duration=2
            ),
        ]

class Enemy(Entity):
    """Enemy character - drops EXP and gold when defeated"""
    
    def __init__(self, name: str, stats: Stats, ascii_art: str, 
                 exp_reward: int, gold_reward: int):
        # Call parent (Entity) constructor
        super().__init__(name, stats, ascii_art)
        
        # Add enemy-specific attributes
        self.exp_reward = exp_reward
        self.gold_reward = gold_reward

# TEST IT IMMEDIATELY:
if __name__ == "__main__":
    print("=== TESTING BUFF/DEBUFF SYSTEM ===\n")
    
    # Create warrior and wizard
    warrior = Warrior("Conan")
    wizard = Wizard("Gandalf")
    
    # Create enemy
    goblin_stats = Stats(hp=100, max_hp=100, mp=10, max_mp=10, 
                        attack=10, speed=6)
    goblin = Enemy("Goblin", goblin_stats, "", 25, 10)
    
    print("=== INITIAL STATS ===")
    print(f"Warrior Attack: {warrior.stats.attack} (Effective: {warrior.stats.get_effective_attack()})")
    print(f"Goblin Attack: {goblin.stats.attack} (Effective: {goblin.stats.get_effective_attack()})")
    print()
    
    # Test buff
    print("=== WARRIOR USES BATTLE CRY (BUFF) ===")
    battle_cry = warrior.skills[2]  # Battle Cry
    damage, msg = warrior.use_skill(battle_cry, warrior)  # Buff self
    print(msg)
    print(f"Warrior Attack: {warrior.stats.attack} (Effective: {warrior.stats.get_effective_attack()})")
    print(f"Status Effects: {warrior.stats.get_status_effects_text()}")
    print()
    
    # Test buffed attack
    print("=== WARRIOR ATTACKS WITH BUFF ===")
    damage, msg = warrior.basic_attack(goblin)
    print(msg)
    print(f"Goblin HP: {goblin.stats.hp}/{goblin.stats.max_hp}")
    print()
    
    # Test debuff
    print("=== WIZARD USES WEAKEN (DEBUFF) ===")
    weaken = wizard.skills[3]  # Weaken
    damage, msg = wizard.use_skill(weaken, goblin)
    print(msg)
    print(f"Goblin Attack: {goblin.stats.attack} (Effective: {goblin.stats.get_effective_attack()})")
    print(f"Status Effects: {goblin.stats.get_status_effects_text()}")
    print()
    
    # Test debuffed attack
    print("=== GOBLIN ATTACKS WITH DEBUFF ===")
    damage, msg = goblin.basic_attack(warrior)
    print(msg)
    print(f"Warrior HP: {warrior.stats.hp}/{warrior.stats.max_hp}")
    print()
    
    # Simulate turns passing
    print("=== TURN 1 ENDS - STATUS EFFECTS TICK ===")
    warrior.stats.tick_status_effects()
    goblin.stats.tick_status_effects()
    print(f"Warrior Status: {warrior.stats.get_status_effects_text()}")
    print(f"Goblin Status: {goblin.stats.get_status_effects_text()}")
    print()
    
    print("=== TURN 2 ENDS - STATUS EFFECTS TICK ===")
    warrior.stats.tick_status_effects()
    goblin.stats.tick_status_effects()
    print(f"Warrior Status: {warrior.stats.get_status_effects_text()}")
    print(f"Goblin Status: {goblin.stats.get_status_effects_text()}")
    print()
    
    print("=== TURN 3 ENDS - STATUS EFFECTS TICK ===")
    warrior.stats.tick_status_effects()
    goblin.stats.tick_status_effects()
    print(f"Warrior Status: {warrior.stats.get_status_effects_text()}")
    print(f"Goblin Status: {goblin.stats.get_status_effects_text()}")
    print(f"Warrior Attack: {warrior.stats.attack} (Effective: {warrior.stats.get_effective_attack()})")
    print(f"Goblin Attack: {goblin.stats.attack} (Effective: {goblin.stats.get_effective_attack()})")
    print()
    
    print("âœ“ Buff/Debuff system working!")
