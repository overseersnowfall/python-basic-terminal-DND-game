import os
import time
import random
from typing import Optional, List, Dict, Tuple
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class StatusEffect:
    """A temporary status effect (buff/debuff/DOT)"""
    name: str           # "Poison", "Burn", "Attack Buff", etc.
    effect_type: str    # "stat_mod", "damage_over_time", "stun", etc.
    stat_affected: str = ""  # "attack", "speed", etc. (for stat_mod type)
    power: int = 0      # Amount (+5 attack, -3 speed, 10 poison damage, etc.)
    duration: int = 0   # Turns remaining
    
    def tick(self) -> bool:
        """
        Reduce duration by 1 turn.
        Returns True if effect is still active, False if expired.
        """
        self.duration -= 1
        return self.duration > 0

@dataclass
class Stats:
    """Character statistics"""
    hp: int
    max_hp: int
    mp: int
    max_mp: int
    attack: int
    speed: int
    level: int = 1
    exp: int = 0
    
    # Status effects list - can hold any number of effects!
    status_effects: List['StatusEffect'] = None
    
    def __post_init__(self):
        """Initialize mutable default (can't do in dataclass directly)"""
        if self.status_effects is None:
            self.status_effects = []
    
    def add_status_effect(self, effect: StatusEffect):
        """Add a new status effect"""
        # Check if same type of effect already exists
        for existing in self.status_effects:
            if existing.name == effect.name:
                # Refresh duration (take the longer one)
                existing.duration = max(existing.duration, effect.duration)
                # Stack power (for things like multiple poisons)
                if effect.effect_type == "damage_over_time":
                    existing.power += effect.power
                return
        
        # Add new effect
        self.status_effects.append(effect)
    
    def remove_status_effect(self, effect_name: str):
        """Remove a status effect by name"""
        self.status_effects = [e for e in self.status_effects if e.name != effect_name]
    
    def get_stat_modifier(self, stat_name: str) -> int:
        """Get total modifier for a stat from all effects"""
        total = 0
        for effect in self.status_effects:
            if effect.effect_type == "stat_mod" and effect.stat_affected == stat_name:
                total += effect.power
        return total
    
    def get_effective_attack(self) -> int:
        """Get attack with all modifiers applied"""
        return max(1, self.attack + self.get_stat_modifier("attack"))
    
    def get_effective_speed(self) -> int:
        """Get speed with all modifiers applied"""
        return max(1, self.speed + self.get_stat_modifier("speed"))
    
    def is_stunned(self) -> bool:
        """Check if character is stunned"""
        return any(e.effect_type == "stun" for e in self.status_effects)
    
    def tick_status_effects(self) -> List[str]:
        """
        Process all status effects for one turn.
        Returns list of messages about what happened.
        """
        messages = []
        effects_to_remove = []
        
        for effect in self.status_effects:
            # Handle damage over time (poison, burn, etc.)
            if effect.effect_type == "damage_over_time":
                damage = self.take_damage(effect.power)
                messages.append(f"ðŸ’€ {effect.name} deals {damage} damage!")
            
            # Tick down duration
            if not effect.tick():
                effects_to_remove.append(effect.name)
                messages.append(f"âœ¨ {effect.name} wore off!")
        
        # Remove expired effects
        for name in effects_to_remove:
            self.remove_status_effect(name)
        
        return messages
    
    def get_status_effects_text(self) -> str:
        """Get text description of all active effects"""
        if not self.status_effects:
            return "None"
        
        effect_strings = []
        for effect in self.status_effects:
            if effect.effect_type == "stat_mod":
                sign = "+" if effect.power > 0 else ""
                effect_strings.append(f"{effect.name} {sign}{effect.power} ({effect.duration}t)")
            elif effect.effect_type == "damage_over_time":
                effect_strings.append(f"{effect.name} {effect.power}/turn ({effect.duration}t)")
            elif effect.effect_type == "stun":
                effect_strings.append(f"{effect.name} ({effect.duration}t)")
        
        return ", ".join(effect_strings)
    
    def take_damage(self, damage: int) -> int:
        actual_damage = max(1, damage)
        self.hp = max(0, self.hp - actual_damage)
        return actual_damage
    
    def heal(self, amount: int) -> int:
        actual_heal = max(1, amount)
        self.hp = min(self.max_hp, self.hp + amount)
        return actual_heal

    def is_alive(self) -> bool:
        return self.hp > 0
    
    def use_mp(self, amount: int) -> bool:
        """
        Try to use MP. Returns True if successful, False if not enough MP.
        """
        if self.mp >= amount:
            self.mp -= amount
            return True
        return False
    
    def restore_mp(self, amount: int):
        """Restore MP, not exceeding max"""
        self.mp = min(self.max_mp, self.mp + amount)

@dataclass
class Skill:
    """A skill/spell that costs MP to use"""
    name: str
    description: str
    mp_cost: int
    skill_type: str  # "damage", "heal", "buff", "debuff", "dot" (damage over time)
    power: float = 0.0
    duration: int = 0
    status_effect: Optional[str] = None  # "poison", "burn", "stun", etc.

class Entity:
    """Base class for all game characters"""
    
    def __init__(self, name: str, stats: Stats, ascii_art: str = ""):
        self.name = name
        self.stats = stats
        self.ascii_art = ascii_art
    
    def basic_attack(self, target: 'Entity') -> Tuple[int, str]:
        """Attack another entity using effective attack (with buffs/debuffs)"""
        # Use effective attack (includes buffs/debuffs)
        effective_attack = self.stats.get_effective_attack()
        damage = int(effective_attack * random.uniform(0.8, 1.2))
        actual_damage = target.stats.take_damage(damage)
        message = f"{self.name} attacks {target.name} for {actual_damage} damage!"
        return actual_damage, message

class Player(Entity, ABC):
    """
    Base Player class - must be subclassed (Warrior, Wizard, etc.)
    ABC = Abstract Base Class
    """
    
    def __init__(self, name: str, stats: Stats, class_name: str, ascii_art: str = ""):
        # Call Entity constructor
        super().__init__(name, stats, ascii_art)
        
        # Add player-specific attributes
        self.class_name = class_name
        self.inventory: List = []  # Empty list for items
        self.skills: List = []     # Empty list for skills
        self.gold: int = 0
        
        # Each subclass will define their own skills
        self._init_skills()
    
    @abstractmethod
    def _init_skills(self):
        """
        Each player class (Warrior, Wizard, etc.) must implement this
        This is where they add their unique skills
        """
        pass
    
    def gain_exp(self, exp: int):
        """Gain experience points"""
        self.stats.exp += exp
        exp_needed = self.stats.level * 100
        
        # Level up if enough exp
        if self.stats.exp >= exp_needed:
            self.level_up()
    
    def level_up(self):
        """Increase level and stats"""
        self.stats.level += 1
        self.stats.max_hp += int(self.stats.max_hp * 0.1)  # Increase max HP by 10%
        self.stats.max_mp += int(self.stats.max_mp * 0.1)  # Increase max MP by 10%
        self.stats.hp = self.stats.max_hp  # Full heal on level up
        self.stats.mp = self.stats.max_mp
        self.stats.attack += int(self.stats.attack * 0.1)  # Increase attack by 10%
        self.stats.speed += 1
        
        print(f"ðŸŽ‰ LEVEL UP! {self.name} is now level {self.stats.level}!")

    def use_skill(self, skill: Skill, target: Entity) -> Tuple[Optional[int], str]:
        """Use a skill on a target"""
        # Check MP
        if not self.stats.use_mp(skill.mp_cost):
            return None, f"Not enough MP! Need {skill.mp_cost} MP."
        
        effect_amount = int(self.stats.attack * skill.power)
        
        if skill.skill_type == "damage":
            # Direct damage
            damage = int(effect_amount * random.uniform(0.9, 1.1))
            actual_damage = target.stats.take_damage(damage)
            message = f"{self.name} uses {skill.name}! Deals {actual_damage} damage!"
            return actual_damage, message
        
        elif skill.skill_type == "heal":
            # Healing
            heal_amount = effect_amount
            target.stats.heal(heal_amount)
            message = f"{self.name} uses {skill.name}! Restored {heal_amount} HP!"
            return 0, message
        
        elif skill.skill_type == "buff":
            # Buff - increase target's stats
            buff_amount = max(1, effect_amount)
            effect = StatusEffect(
                name=f"{skill.name}",
                effect_type="stat_mod",
                stat_affected="attack",  # For now, all buffs affect attack
                power=buff_amount,
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name}'s attack +{buff_amount} for {skill.duration} turns!"
            return 0, message
        
        elif skill.skill_type == "debuff":
            # Debuff - decrease target's stats
            debuff_amount = max(1, effect_amount)
            effect = StatusEffect(
                name=f"{skill.name}",
                effect_type="stat_mod",
                stat_affected="attack",
                power=-debuff_amount,
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name}'s attack -{debuff_amount} for {skill.duration} turns!"
            return 0, message
        
        elif skill.skill_type == "dot":
            # Damage over time (poison, burn, bleed, etc.)
            dot_damage = max(1, effect_amount)
            effect = StatusEffect(
                name=skill.status_effect or skill.name,  # Use custom name or skill name
                effect_type="damage_over_time",
                power=dot_damage,
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name} is afflicted with {effect.name}!"
            return 0, message
        
        elif skill.skill_type == "stun":
            # Stun effect
            effect = StatusEffect(
                name="Stunned",
                effect_type="stun",
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name} is stunned for {skill.duration} turns!"
            return 0, message
        
        else:
            return None, f"Unknown skill type: {skill.skill_type}"

class Warrior(Player):
    """Warrior - High HP, powerful physical attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=120, max_hp=120,
            mp=30, max_mp=30,
            attack=18,
            speed=8
        )
        super().__init__(name, stats, "Warrior")
    
    def _init_skills(self):
        """Warrior gets physical damage skills and buffs"""
        self.skills = [
            Skill(
                name="Power Strike",
                description="Heavy attack dealing 150% damage",
                mp_cost=10,
                skill_type="damage",
                power=1.5
            ),
            Skill(
                name="Whirlwind",
                description="Spinning attack dealing 200% damage",
                mp_cost=20,
                skill_type="damage",
                power=2.0
            ),
            Skill(
                name="Battle Cry",
                description="Boost attack by 30% for 3 turns",
                mp_cost=15,
                skill_type="buff",
                power=0.3,  # 30% of attack
                duration=3
            ),
        ]

class Wizard(Player):
    """Wizard - High MP, powerful magic attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=80, max_hp=80,
            mp=60, max_mp=60,
            attack=12,
            speed=10
        )
        super().__init__(name, stats, "Wizard")
    
    def _init_skills(self):
        """Wizard gets various magic types"""
        self.skills = [
            Skill(
                name="Fireball",
                description="Fire spell dealing 160% damage",
                mp_cost=12,
                skill_type="damage",
                power=1.6
            ),
            Skill(
                name="Poison Cloud",
                description="Poison enemy for 50% attack/turn for 3 turns",
                mp_cost=15,
                skill_type="dot",
                power=0.5,  # 50% of attack per turn
                duration=3,
                status_effect="Poison"
            ),
            Skill(
                name="Flame Curse",
                description="Burn enemy for 40% attack/turn for 4 turns",
                mp_cost=18,
                skill_type="dot",
                power=0.4,
                duration=4,
                status_effect="Burn"
            ),
            Skill(
                name="Heal",
                description="Restore HP based on 80% of attack",
                mp_cost=15,
                skill_type="heal",
                power=0.8
            ),
        ]


class Thief(Player):
    """Thief - Status effects and crits"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=90, max_hp=90,
            mp=35, max_mp=35,
            attack=14,
            speed=15
        )
        super().__init__(name, stats, "Thief")
    
    def _init_skills(self):
        """Thief gets bleed and stun effects"""
        self.skills = [
            Skill(
                name="Backstab",
                description="Critical strike dealing 170% damage",
                mp_cost=10,
                skill_type="damage",
                power=1.7
            ),
            Skill(
                name="Poison Blade",
                description="Attack that poisons for 60% attack/turn for 3 turns",
                mp_cost=12,
                skill_type="dot",
                power=0.6,
                duration=3,
                status_effect="Poison"
            ),
            Skill(
                name="Stunning Strike",
                description="Stun enemy for 1 turn",
                mp_cost=15,
                skill_type="stun",
                duration=1
            ),
        ]

class Ranger(Player):
    """Ranger - Balanced stats, ranged attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=100, max_hp=100,
            mp=40, max_mp=40,
            attack=15,
            speed=12
        )
        super().__init__(name, stats, "Ranger")
    
    def _init_skills(self):
        """Ranger gets precision attacks"""
        self.skills = [
            Skill(
                name="Rapid Shot",
                description="Quick attack dealing 130% damage",
                mp_cost=8,
                skill_type="damage",
                power=1.3
            ),
            Skill(
                name="Piercing Arrow",
                description="Armor-piercing shot dealing 180% damage",
                mp_cost=15,
                skill_type="damage",
                power=1.8
            ),
        ]

class Enemy(Entity):
    """Enemy character - drops EXP and gold when defeated"""
    
    def __init__(self, name: str, stats: Stats, ascii_art: str, 
                 exp_reward: int, gold_reward: int):
        # Call parent (Entity) constructor
        super().__init__(name, stats, ascii_art)
        
        # Add enemy-specific attributes
        self.exp_reward = exp_reward
        self.gold_reward = gold_reward

# TEST IT IMMEDIATELY:
if __name__ == "__main__":
    print("=== TESTING BUFF/DEBUFF SYSTEM ===\n")
    
    # Create warrior and wizard
    warrior = Warrior("Conan")
    wizard = Wizard("Gandalf")
    
    # Create enemy
    goblin_stats = Stats(hp=100, max_hp=100, mp=10, max_mp=10, 
                        attack=10, speed=6)
    goblin = Enemy("Goblin", goblin_stats, "", 25, 10)
    
    print("=== INITIAL STATS ===")
    print(f"Warrior Attack: {warrior.stats.attack} (Effective: {warrior.stats.get_effective_attack()})")
    print(f"Goblin Attack: {goblin.stats.attack} (Effective: {goblin.stats.get_effective_attack()})")
    print()
    
    # Test buff
    print("=== WARRIOR USES BATTLE CRY (BUFF) ===")
    battle_cry = warrior.skills[2]  # Battle Cry
    damage, msg = warrior.use_skill(battle_cry, warrior)  # Buff self
    print(msg)
    print(f"Warrior Attack: {warrior.stats.attack} (Effective: {warrior.stats.get_effective_attack()})")
    print(f"Status Effects: {warrior.stats.get_status_effects_text()}")
    print()
    
    # Test buffed attack
    print("=== WARRIOR ATTACKS WITH BUFF ===")
    damage, msg = warrior.basic_attack(goblin)
    print(msg)
    print(f"Goblin HP: {goblin.stats.hp}/{goblin.stats.max_hp}")
    print()
    
    # Test debuff
    print("=== WIZARD USES WEAKEN (DEBUFF) ===")
    weaken = wizard.skills[3]  # Weaken
    damage, msg = wizard.use_skill(weaken, goblin)
    print(msg)
    print(f"Goblin Attack: {goblin.stats.attack} (Effective: {goblin.stats.get_effective_attack()})")
    print(f"Status Effects: {goblin.stats.get_status_effects_text()}")
    print()
    
    # Test debuffed attack
    print("=== GOBLIN ATTACKS WITH DEBUFF ===")
    damage, msg = goblin.basic_attack(warrior)
    print(msg)
    print(f"Warrior HP: {warrior.stats.hp}/{warrior.stats.max_hp}")
    print()
    
    # Simulate turns passing
    print("=== TURN 1 ENDS - STATUS EFFECTS TICK ===")
    warrior.stats.tick_status_effects()
    goblin.stats.tick_status_effects()
    print(f"Warrior Status: {warrior.stats.get_status_effects_text()}")
    print(f"Goblin Status: {goblin.stats.get_status_effects_text()}")
    print()
    
    print("=== TURN 2 ENDS - STATUS EFFECTS TICK ===")
    warrior.stats.tick_status_effects()
    goblin.stats.tick_status_effects()
    print(f"Warrior Status: {warrior.stats.get_status_effects_text()}")
    print(f"Goblin Status: {goblin.stats.get_status_effects_text()}")
    print()
    
    print("=== TURN 3 ENDS - STATUS EFFECTS TICK ===")
    warrior.stats.tick_status_effects()
    goblin.stats.tick_status_effects()
    print(f"Warrior Status: {warrior.stats.get_status_effects_text()}")
    print(f"Goblin Status: {goblin.stats.get_status_effects_text()}")
    print(f"Warrior Attack: {warrior.stats.attack} (Effective: {warrior.stats.get_effective_attack()})")
    print(f"Goblin Attack: {goblin.stats.attack} (Effective: {goblin.stats.get_effective_attack()})")
    print()
    
    print("âœ“ Buff/Debuff system working!")
