import os
import time
import random
from typing import Optional, List, Dict, Tuple
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class StatusEffect:
    """A temporary status effect (buff/debuff/DOT)"""
    name: str           # "Poison", "Burn", "Attack Buff", etc.
    effect_type: str    # "stat_mod", "damage_over_time", "stun", etc.
    stat_affected: str = ""  # "attack", "speed", etc. (for stat_mod type)
    power: int = 0      # Amount (+5 attack, -3 speed, 10 poison damage, etc.)
    duration: int = 0   # Turns remaining
    
    def tick(self) -> bool:
        """
        Reduce duration by 1 turn.
        Returns True if effect is still active, False if expired.
        """
        self.duration -= 1
        return self.duration > 0

@dataclass
class Stats:
    """Character statistics"""
    hp: int
    max_hp: int
    mp: int
    max_mp: int
    attack: int
    speed: int
    level: int = 1
    exp: int = 0
    
    # Status effects list - can hold any number of effects!
    status_effects: List['StatusEffect'] = None
    
    def __post_init__(self):
        """Initialize mutable default (can't do in dataclass directly)"""
        if self.status_effects is None:
            self.status_effects = []
    
    def add_status_effect(self, effect: StatusEffect):
        """Add a new status effect"""
        # Check if same type of effect already exists
        for existing in self.status_effects:
            if existing.name == effect.name:
                # Refresh duration (take the longer one)
                existing.duration = max(existing.duration, effect.duration)
                # Stack power (for things like multiple poisons)
                if effect.effect_type == "damage_over_time":
                    existing.power += effect.power
                return
        
        # Add new effect
        self.status_effects.append(effect)
    
    def remove_status_effect(self, effect_name: str):
        """Remove a status effect by name"""
        self.status_effects = [e for e in self.status_effects if e.name != effect_name]
    
    def get_stat_modifier(self, stat_name: str) -> int:
        """Get total modifier for a stat from all effects"""
        total = 0
        for effect in self.status_effects:
            if effect.effect_type == "stat_mod" and effect.stat_affected == stat_name:
                total += effect.power
        return total
    
    def get_effective_attack(self) -> int:
        """Get attack with all modifiers applied"""
        return max(1, self.attack + self.get_stat_modifier("attack"))
    
    def get_effective_speed(self) -> int:
        """Get speed with all modifiers applied"""
        return max(1, self.speed + self.get_stat_modifier("speed"))
    
    def is_stunned(self) -> bool:
        """Check if character is stunned"""
        return any(e.effect_type == "stun" for e in self.status_effects)
    
    def tick_status_effects(self) -> List[str]:
        """
        Process all status effects for one turn.
        Returns list of messages about what happened.
        """
        messages = []
        effects_to_remove = []
        
        for effect in self.status_effects:
            # Handle damage over time (poison, burn, etc.)
            if effect.effect_type == "damage_over_time":
                damage = self.take_damage(effect.power)
                messages.append(f"ğŸ’€ {effect.name} deals {damage} damage!")
            
            # Tick down duration
            if not effect.tick():
                effects_to_remove.append(effect.name)
                messages.append(f"âœ¨ {effect.name} wore off!")
        
        # Remove expired effects
        for name in effects_to_remove:
            self.remove_status_effect(name)
        
        return messages
    
    def get_status_effects_text(self) -> str:
        """Get text description of all active effects"""
        if not self.status_effects:
            return "None"
        
        effect_strings = []
        for effect in self.status_effects:
            if effect.effect_type == "stat_mod":
                sign = "+" if effect.power > 0 else ""
                effect_strings.append(f"{effect.name} {sign}{effect.power} ({effect.duration}t)")
            elif effect.effect_type == "damage_over_time":
                effect_strings.append(f"{effect.name} {effect.power}/turn ({effect.duration}t)")
            elif effect.effect_type == "stun":
                effect_strings.append(f"{effect.name} ({effect.duration}t)")
        
        return ", ".join(effect_strings)
    
    def take_damage(self, damage: int) -> int:
        actual_damage = max(1, damage)
        self.hp = max(0, self.hp - actual_damage)
        return actual_damage
    
    def heal(self, amount: int) -> int:
        actual_heal = max(1, amount)
        self.hp = min(self.max_hp, self.hp + amount)
        return actual_heal

    def is_alive(self) -> bool:
        return self.hp > 0
    
    def use_mp(self, amount: int) -> bool:
        """
        Try to use MP. Returns True if successful, False if not enough MP.
        """
        if self.mp >= amount:
            self.mp -= amount
            return True
        return False
    
    def restore_mp(self, amount: int):
        """Restore MP, not exceeding max"""
        self.mp = min(self.max_mp, self.mp + amount)

@dataclass
class Skill:
    """A skill/spell that costs MP to use"""
    name: str
    description: str
    mp_cost: int
    skill_type: str  # "damage", "heal", "buff", "debuff", "dot" (damage over time)
    power: float = 0.0
    duration: int = 0
    status_effect: Optional[str] = None  # "poison", "burn", "stun", etc.

@dataclass
class Item:
    """Game items - potions, keys, etc."""
    name: str
    description: str
    item_type: str  # 'potion', 'ether', 'key', etc.
    effect: Dict = None  # e.g., {'hp': 40} or {'mp': 30}

class Display:
    """Helper methods for terminal display"""
    
    @staticmethod
    def clear_screen():
        """Clear the terminal screen"""
        os.system('cls' if os.name == 'nt' else 'clear')
        # 'cls' for Windows, 'clear' for Mac/Linux
    
    @staticmethod
    def get_terminal_size() -> Tuple[int, int]:
        """
        Get terminal dimensions
        Returns: (width, height) in characters
        """
        try:
            size = os.get_terminal_size()
            return size.columns, size.lines
        except:
            return 100, 30  # Fallback if can't detect
    
    @staticmethod
    def center_text(text: str, width: int) -> str:
        """Center text within given width"""
        padding = (width - len(text)) // 2
        return " " * padding + text
    
    @staticmethod
    def render_ascii_art(art: str, width: int) -> List[str]:
        """
        Prepare ASCII art for display, centered in the given width
        Returns list of centered lines
        """
        lines = art.split('\n')
        centered_lines = []
        
        for line in lines:
            if len(line) < width - 4:  # Account for box borders
                centered_lines.append(Display.center_text(line, width - 2))
            else:
                # Truncate if too long
                centered_lines.append(line[:width-4])
        
        return centered_lines

class Entity:
    """Base class for all game characters"""
    
    def __init__(self, name: str, stats: Stats, ascii_art: str = ""):
        self.name = name
        self.stats = stats
        self.ascii_art = ascii_art
    
    def basic_attack(self, target: 'Entity') -> Tuple[int, str]:
        """Attack another entity using effective attack (with buffs/debuffs)"""
        # Use effective attack (includes buffs/debuffs)
        effective_attack = self.stats.get_effective_attack()
        damage = int(effective_attack * random.uniform(0.8, 1.2))
        actual_damage = target.stats.take_damage(damage)
        message = f"{self.name} attacks {target.name} for {actual_damage} damage!"
        return actual_damage, message

class Player(Entity, ABC):
    """
    Base Player class - must be subclassed (Warrior, Wizard, etc.)
    ABC = Abstract Base Class
    """
    
    def __init__(self, name: str, stats: Stats, class_name: str, ascii_art: str = ""):
        # Call Entity constructor
        super().__init__(name, stats, ascii_art)
        
        # Add player-specific attributes
        self.class_name = class_name
        self.inventory: List = []  # Empty list for items
        self.skills: List = []     # Empty list for skills
        self.gold: int = 0
        
        # Each subclass will define their own skills
        self._init_skills()
    
    @abstractmethod
    def _init_skills(self):
        """
        Each player class (Warrior, Wizard, etc.) must implement this
        This is where they add their unique skills
        """
        pass
    
    def gain_exp(self, exp: int):
        """Gain experience points"""
        self.stats.exp += exp
        exp_needed = self.stats.level * 100
        
        # Level up if enough exp
        if self.stats.exp >= exp_needed:
            self.level_up()
    
    def level_up(self):
        """Increase level and stats"""
        self.stats.level += 1
        self.stats.max_hp += int(self.stats.max_hp * 0.1)  # Increase max HP by 10%
        self.stats.max_mp += int(self.stats.max_mp * 0.1)  # Increase max MP by 10%
        self.stats.hp = self.stats.max_hp  # Full heal on level up
        self.stats.mp = self.stats.max_mp
        self.stats.attack += int(self.stats.attack * 0.1)  # Increase attack by 10%
        self.stats.speed += 1
        
        print(f"ğŸ‰ LEVEL UP! {self.name} is now level {self.stats.level}!")

    def add_item(self, item: 'Item'):
        """Add item to inventory"""
        self.inventory.append(item)
    
    def use_item(self, item_name: str) -> Optional[str]:
        """Use an item from inventory"""
        for item in self.inventory:
            if item.name.lower() == item_name.lower():
                if item.effect:
                    # Health potion
                    if 'hp' in item.effect:
                        self.stats.heal(item.effect['hp'])
                        self.inventory.remove(item)
                        return f"Used {item.name}! Restored {item.effect['hp']} HP."
                    # Mana potion
                    elif 'mp' in item.effect:
                        self.stats.restore_mp(item.effect['mp'])
                        self.inventory.remove(item)
                        return f"Used {item.name}! Restored {item.effect['mp']} MP."
                return f"Used {item.name}."
        return None

    def use_skill(self, skill: Skill, target: Entity) -> Tuple[Optional[int], str]:
        """Use a skill on a target"""
        # Check MP
        if not self.stats.use_mp(skill.mp_cost):
            return None, f"Not enough MP! Need {skill.mp_cost} MP."
        
        effect_amount = int(self.stats.attack * skill.power)
        
        if skill.skill_type == "damage":
            # Direct damage
            damage = int(effect_amount * random.uniform(0.9, 1.1))
            actual_damage = target.stats.take_damage(damage)
            message = f"{self.name} uses {skill.name}! Deals {actual_damage} damage!"
            return actual_damage, message
        
        elif skill.skill_type == "heal":
            # Healing
            heal_amount = effect_amount
            target.stats.heal(heal_amount)
            message = f"{self.name} uses {skill.name}! Restored {heal_amount} HP!"
            return 0, message
        
        elif skill.skill_type == "buff":
            # Buff - increase target's stats
            buff_amount = max(1, effect_amount)
            effect = StatusEffect(
                name=f"{skill.name}",
                effect_type="stat_mod",
                stat_affected="attack",  # For now, all buffs affect attack
                power=buff_amount,
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name}'s attack +{buff_amount} for {skill.duration} turns!"
            return 0, message
        
        elif skill.skill_type == "debuff":
            # Debuff - decrease target's stats
            debuff_amount = max(1, effect_amount)
            effect = StatusEffect(
                name=f"{skill.name}",
                effect_type="stat_mod",
                stat_affected="attack",
                power=-debuff_amount,
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name}'s attack -{debuff_amount} for {skill.duration} turns!"
            return 0, message
        
        elif skill.skill_type == "dot":
            # Damage over time (poison, burn, bleed, etc.)
            dot_damage = max(1, effect_amount)
            effect = StatusEffect(
                name=skill.status_effect or skill.name,  # Use custom name or skill name
                effect_type="damage_over_time",
                power=dot_damage,
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name} is afflicted with {effect.name}!"
            return 0, message
        
        elif skill.skill_type == "stun":
            # Stun effect
            effect = StatusEffect(
                name="Stunned",
                effect_type="stun",
                duration=skill.duration
            )
            target.stats.add_status_effect(effect)
            message = f"{self.name} uses {skill.name}! {target.name} is stunned for {skill.duration} turns!"
            return 0, message
        
        else:
            return None, f"Unknown skill type: {skill.skill_type}"

class Warrior(Player):
    """Warrior - High HP, powerful physical attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=120, max_hp=120,
            mp=30, max_mp=30,
            attack=18,
            speed=8
        )
        super().__init__(name, stats, "Warrior")
    
    def _init_skills(self):
        """Warrior gets physical damage skills and buffs"""
        self.skills = [
            Skill(
                name="Power Strike",
                description="Heavy attack dealing 150% damage",
                mp_cost=10,
                skill_type="damage",
                power=1.5
            ),
            Skill(
                name="Whirlwind",
                description="Spinning attack dealing 200% damage",
                mp_cost=20,
                skill_type="damage",
                power=2.0
            ),
            Skill(
                name="Battle Cry",
                description="Boost attack by 30% for 3 turns",
                mp_cost=15,
                skill_type="buff",
                power=0.3,  # 30% of attack
                duration=3
            ),
        ]

class Wizard(Player):
    """Wizard - High MP, powerful magic attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=80, max_hp=80,
            mp=60, max_mp=60,
            attack=12,
            speed=10
        )
        super().__init__(name, stats, "Wizard")
    
    def _init_skills(self):
        """Wizard gets various magic types"""
        self.skills = [
            Skill(
                name="Fireball",
                description="Fire spell dealing 160% damage",
                mp_cost=12,
                skill_type="damage",
                power=1.6
            ),
            Skill(
                name="Poison Cloud",
                description="Poison enemy for 50% attack/turn for 3 turns",
                mp_cost=15,
                skill_type="dot",
                power=0.5,  # 50% of attack per turn
                duration=3,
                status_effect="Poison"
            ),
            Skill(
                name="Flame Curse",
                description="Burn enemy for 40% attack/turn for 4 turns",
                mp_cost=18,
                skill_type="dot",
                power=0.4,
                duration=4,
                status_effect="Burn"
            ),
            Skill(
                name="Heal",
                description="Restore HP based on 80% of attack",
                mp_cost=15,
                skill_type="heal",
                power=0.8
            ),
        ]


class Thief(Player):
    """Thief - Status effects and crits"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=90, max_hp=90,
            mp=35, max_mp=35,
            attack=14,
            speed=15
        )
        super().__init__(name, stats, "Thief")
    
    def _init_skills(self):
        """Thief gets bleed and stun effects"""
        self.skills = [
            Skill(
                name="Backstab",
                description="Critical strike dealing 170% damage",
                mp_cost=10,
                skill_type="damage",
                power=1.7
            ),
            Skill(
                name="Poison Blade",
                description="Attack that poisons for 60% attack/turn for 3 turns",
                mp_cost=12,
                skill_type="dot",
                power=0.6,
                duration=3,
                status_effect="Poison"
            ),
            Skill(
                name="Stunning Strike",
                description="Stun enemy for 1 turn",
                mp_cost=15,
                skill_type="stun",
                duration=1
            ),
        ]

class Ranger(Player):
    """Ranger - Balanced stats, ranged attacks"""
    
    def __init__(self, name: str):
        stats = Stats(
            hp=100, max_hp=100,
            mp=40, max_mp=40,
            attack=15,
            speed=12
        )
        super().__init__(name, stats, "Ranger")
    
    def _init_skills(self):
        """Ranger gets precision attacks"""
        self.skills = [
            Skill(
                name="Rapid Shot",
                description="Quick attack dealing 130% damage",
                mp_cost=8,
                skill_type="damage",
                power=1.3
            ),
            Skill(
                name="Piercing Arrow",
                description="Armor-piercing shot dealing 180% damage",
                mp_cost=15,
                skill_type="damage",
                power=1.8
            ),
        ]

class Enemy(Entity):
    """Enemy character - drops EXP and gold when defeated"""
    
    def __init__(self, name: str, stats: Stats, ascii_art: str, 
                 exp_reward: int, gold_reward: int):
        # Call parent (Entity) constructor
        super().__init__(name, stats, ascii_art)
        
        # Add enemy-specific attributes
        self.exp_reward = exp_reward
        self.gold_reward = gold_reward

class GameScreen:
    """Manages the split-screen game layout"""
    
    def __init__(self):
        self.width, self.height = Display.get_terminal_size()
        
        # Screen divisions
        self.visual_height = int(self.height * 0.4)  # 40% for enemy/scene
        self.stats_height = 8  # Fixed 8 lines for stats
        self.story_height = self.height - self.visual_height - self.stats_height - 4
        # -4 for borders/dividers
    
    def _draw_horizontal_line(self, style: str = "double") -> str:
        """Draw a horizontal divider line"""
        if style == "double":
            return "â• " + "â•" * (self.width - 2) + "â•£"
        else:
            return "â”œ" + "â”€" * (self.width - 2) + "â”¤"
    
    def _draw_health_bar(self, current: int, maximum: int, width: int = 20) -> str:
        """
        Draw a visual health bar
        Example: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘] 80/100
        """
        if maximum == 0:
            percentage = 0
        else:
            percentage = current / maximum
        
        filled = int(percentage * width)
        empty = width - filled
        
        bar = "â–ˆ" * filled + "â–‘" * empty
        return f"[{bar}] {current}/{maximum}"
    
    def _draw_mp_bar(self, current: int, maximum: int, width: int = 20) -> str:
        """Draw a visual MP bar (similar to health bar)"""
        if maximum == 0:
            percentage = 0
        else:
            percentage = current / maximum
        
        filled = int(percentage * width)
        empty = width - filled
        
        bar = "â–“" * filled + "â–‘" * empty
        return f"[{bar}] {current}/{maximum}"
    
    def render_combat_screen(self, player: Player, enemy: Enemy, messages: List[str]):
        """
        Render the combat view with simple text stats (no visual bars)
        """
        Display.clear_screen()

        # ===== TOP SECTION: Enemy Visual =====
        print("â•”" + "â•" * (self.width - 2) + "â•—")

        # Render enemy ASCII art
        art_lines = Display.render_ascii_art(enemy.ascii_art, self.width)
        for i in range(self.visual_height - 2):
            if i < len(art_lines):
                print("â•‘" + art_lines[i].ljust(self.width - 2) + "â•‘")
            else:
                print("â•‘" + " " * (self.width - 2) + "â•‘")

        # ===== MIDDLE SECTION: Stats Side-by-Side =====
        print(self._draw_horizontal_line())

        # Calculate column widths (50/50 split)
        col_width = (self.width - 3) // 2

        # Build player stats lines
        player_lines = [
            "â•”" + "â•" * (col_width - 1) + "â•—",
            f"â•‘ {player.name} ({player.class_name})".ljust(col_width) + "â•‘",
            f"â•‘ Level: {player.stats.level}".ljust(col_width) + "â•‘",
            f"â•‘ HP: {player.stats.hp}/{player.stats.max_hp}".ljust(col_width) + "â•‘",
            f"â•‘ MP: {player.stats.mp}/{player.stats.max_mp}".ljust(col_width) + "â•‘",
            f"â•‘ ATK: {player.stats.get_effective_attack()} | SPD: {player.stats.get_effective_speed()}".ljust(col_width) + "â•‘",
            f"â•‘ Status: {player.stats.get_status_effects_text()[:col_width-10]}".ljust(col_width) + "â•‘",
            "â•š" + "â•" * (col_width - 1) + "â•",
        ]

        # Build enemy stats lines
        enemy_lines = [
            "â•”" + "â•" * (col_width - 1) + "â•—",
            f"â•‘ {enemy.name}".ljust(col_width) + "â•‘",
            f"â•‘ Level: {enemy.stats.level}".ljust(col_width) + "â•‘",
            f"â•‘ HP: {enemy.stats.hp}/{enemy.stats.max_hp}".ljust(col_width) + "â•‘",
            f"â•‘ MP: {enemy.stats.mp}/{enemy.stats.max_mp}".ljust(col_width) + "â•‘",
            f"â•‘ ATK: {enemy.stats.get_effective_attack()} | SPD: {enemy.stats.get_effective_speed()}".ljust(col_width) + "â•‘",
            f"â•‘ Status: {enemy.stats.get_status_effects_text()[:col_width-10]}".ljust(col_width) + "â•‘",
            "â•š" + "â•" * (col_width - 1) + "â•",
        ]

        # Print stats side by side
        for p_line, e_line in zip(player_lines, enemy_lines):
            print("â•‘" + p_line + "â”‚" + e_line + "â•‘")

        # ===== BOTTOM SECTION: Combat Log and Options =====
        print(self._draw_horizontal_line())

        # Combat log header
        print("â•‘ " + "COMBAT LOG".ljust(self.width - 3) + "â•‘")
        print("â•‘" + "â”€" * (self.width - 2) + "â•‘")

        # Show last few messages
        for msg in messages[-5:]:  # Last 5 messages
            # Truncate if too long
            display_msg = msg[:self.width - 4]
            print("â•‘ " + display_msg.ljust(self.width - 3) + "â•‘")

        # Fill remaining space
        used_lines = 2 + len(messages[-5:])
        for _ in range(self.story_height - used_lines - 2):
            print("â•‘" + " " * (self.width - 2) + "â•‘")

        # Options
        print(self._draw_horizontal_line())
        print("â•‘ [1] Attack  [2] Skills  [3] Items  [4] Run".ljust(self.width - 1) + "â•‘")
        print("â•š" + "â•" * (self.width - 2) + "â•")
    
    def render_exploration_screen(self, player: Player, story_text: str, options: List[str]):
        """
        Render the exploration view:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     TOP: SCENE ASCII ART        â”‚  40%
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚     PLAYER STATS                â”‚  1 line
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚     STORY TEXT                  â”‚
        â”‚     OPTIONS                     â”‚  Remaining
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        """
        Display.clear_screen()
        
        # ===== TOP: Scene Art =====
        print("â•”" + "â•" * (self.width - 2) + "â•—")
        
        scene_art = """
            ğŸ° THE DUNGEON DEPTHS ğŸ°
            
               You venture deeper into darkness...
        """
        art_lines = Display.render_ascii_art(scene_art, self.width)
        
        for i in range(self.visual_height - 2):
            if i < len(art_lines):
                print("â•‘" + art_lines[i].ljust(self.width - 2) + "â•‘")
            else:
                print("â•‘" + " " * (self.width - 2) + "â•‘")
        
        # ===== MIDDLE: Player Stats =====
        print(self._draw_horizontal_line())
        
        player_info = (f"[{player.name} - {player.class_name}] "
                      f"LVL:{player.stats.level} | "
                      f"HP:{player.stats.hp}/{player.stats.max_hp} | "
                      f"MP:{player.stats.mp}/{player.stats.max_mp} | "
                      f"Gold:{player.gold} | "
                      f"EXP:{player.stats.exp}")
        print("â•‘ " + player_info.ljust(self.width - 3) + "â•‘")
        
        # ===== BOTTOM: Story and Options =====
        print(self._draw_horizontal_line())
        
        # Word wrap story text
        words = story_text.split()
        lines = []
        current_line = ""
        
        for word in words:
            if len(current_line) + len(word) + 1 < self.width - 4:
                current_line += word + " "
            else:
                lines.append(current_line.strip())
                current_line = word + " "
        
        if current_line:
            lines.append(current_line.strip())
        
        # Print story text
        for line in lines[:self.story_height - 4]:
            print("â•‘ " + line.ljust(self.width - 3) + "â•‘")
        
        # Divider before options
        print("â•‘" + "â”€" * (self.width - 2) + "â•‘")
        
        # Print options
        for i, option in enumerate(options, 1):
            option_text = f"[{i}] {option}"
            print("â•‘ " + option_text.ljust(self.width - 3) + "â•‘")
        
        # Fill remaining space
        used = len(lines[:self.story_height - 4]) + 1 + len(options)
        for _ in range(self.story_height - used - 1):
            print("â•‘" + " " * (self.width - 2) + "â•‘")
        
        print("â•š" + "â•" * (self.width - 2) + "â•")
    
    def render_skill_menu(self, player: Player):
        """Display skill selection menu"""
        Display.clear_screen()
        
        print("â•”" + "â•" * (self.width - 2) + "â•—")
        print("â•‘" + "SKILLS".center(self.width - 2) + "â•‘")
        print("â• " + "â•" * (self.width - 2) + "â•£")
        
        for i, skill in enumerate(player.skills, 1):
            skill_line = (f" [{i}] {skill.name} (MP: {skill.mp_cost}) - "
                         f"{skill.description}")
            print("â•‘" + skill_line.ljust(self.width - 2) + "â•‘")
        
        print("â•‘" + " [0] Back".ljust(self.width - 2) + "â•‘")
        
        # Fill space
        used = 3 + len(player.skills) + 1
        for _ in range(self.height - used - 2):
            print("â•‘" + " " * (self.width - 2) + "â•‘")
        
        print("â•š" + "â•" * (self.width - 2) + "â•")
    
    def render_inventory_menu(self, player: Player):
        """Display inventory selection menu"""
        Display.clear_screen()
        
        print("â•”" + "â•" * (self.width - 2) + "â•—")
        print("â•‘" + "INVENTORY".center(self.width - 2) + "â•‘")
        print("â• " + "â•" * (self.width - 2) + "â•£")
        
        if not player.inventory:
            print("â•‘" + "  (Empty)".ljust(self.width - 2) + "â•‘")
        else:
            for i, item in enumerate(player.inventory, 1):
                item_line = f" [{i}] {item.name} - {item.description}"
                print("â•‘" + item_line.ljust(self.width - 2) + "â•‘")
        
        print("â•‘" + " [0] Back".ljust(self.width - 2) + "â•‘")
        
        # Fill space
        used = 3 + (len(player.inventory) if player.inventory else 1) + 1
        for _ in range(self.height - used - 2):
            print("â•‘" + " " * (self.width - 2) + "â•‘")
        
        print("â•š" + "â•" * (self.width - 2) + "â•")

if __name__ == "__main__":
    print("=== TESTING GAME SCREEN ===\n")
    
    # Create test data
    warrior = Warrior("Conan")
    wizard = Wizard("Gandalf")
    
    # Give warrior some damage and status effects for visual testing
    warrior.stats.take_damage(30)
    warrior.stats.use_mp(10)
    warrior.stats.add_status_effect(StatusEffect(
        name="Battle Cry",
        effect_type="stat_mod",
        stat_affected="attack",
        power=5,
        duration=3
    ))
    
    # Create enemy
    goblin_art = """
        .--.
       (o.o )
        |=|
       __|__
      //.=|=.\\\\
     // .=|=. \\\\
     \\\\ .=|=. //
      \\\\(_=_)//
       (:| |:)
        || ||
    """
    
    goblin = Enemy(
        name="Goblin Scout",
        stats=Stats(hp=25, max_hp=40, mp=5, max_mp=10, 
                   attack=8, speed=6),
        ascii_art=goblin_art,
        exp_reward=25,
        gold_reward=10
    )
    
    # Add poison to goblin
    goblin.stats.add_status_effect(StatusEffect(
        name="Poison",
        effect_type="damage_over_time",
        power=5,
        duration=2
    ))
    
    # Create screen
    screen = GameScreen()
    
    # Test combat screen
    messages = [
        "A wild Goblin Scout appears!",
        "Conan attacks Goblin Scout for 16 damage!",
        "Goblin Scout attacks Conan for 7 damage!",
        "Conan uses Power Strike! Deals 24 damage!",
        "ğŸ’€ Poison deals 5 damage to Goblin Scout!",
    ]
    
    print("Testing COMBAT screen...")
    screen.render_combat_screen(warrior, goblin, messages)
    input("\nPress Enter to continue...")
    
    # Test exploration screen
    print("\nTesting EXPLORATION screen...")
    story = ("You stand at a crossroads in the dungeon. To the north, you hear "
            "the sound of dripping water. To the east, you see a faint glow. "
            "To the south, the passage slopes downward into darkness.")
    options = ["Go north", "Go east", "Go south", "Rest", "Check inventory"]
    
    screen.render_exploration_screen(wizard, story, options)
    input("\nPress Enter to continue...")
    
    # Test skill menu
    print("\nTesting SKILL MENU...")
    screen.render_skill_menu(warrior)
    input("\nPress Enter to continue...")
    
    # Test inventory
    print("\nTesting INVENTORY MENU...")
    warrior.add_item(Item("Health Potion", "Restores 40 HP", "potion", {"hp": 40}))
    warrior.add_item(Item("Mana Potion", "Restores 30 MP", "ether", {"mp": 30}))
    screen.render_inventory_menu(warrior)
    input("\nPress Enter to finish...")
    
    Display.clear_screen()
    print("âœ“ Game screen working!\n")
